<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Notifications</title>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <style>
         :root {
         /* Colors - Dark Theme */
         --bg-primary: #121212;
         --bg-secondary: #1f1f1f;
         --bg-tertiary: #333333;
         --bg-gradient-dark: linear-gradient(145deg, #1e1e1e, #333333);
         --bg-input: #2c2c2c;
         --bg-profile: rgb(25, 25, 25);
         /* Text Colors - Dark Theme */
         --text-primary: #fff;
         --text-secondary: #ddd;
         --text-tertiary: #b0bec5;
         --text-muted: rgb(230, 230, 230);
         --text-light-gray: rgb(240, 240, 240);
         --text-dark-gray: rgb(220, 220, 220);
         /* Accent Colors */
         --accent-primary: #ffc107;
         --accent-hover: #e0a800;
         --accent-focus: #ffd54f;
         --accent-button-text: black;
         /* Logout button specific â€” remain same for light and dark themes */
         --logout-bg: #e53935;
         --logout-text: #fff;
         --logout-hover: #d32f2f;
         /* Status Colors */
         --error-color: #FF3333;
         --error-bg: #e53935;
         --error-hover: #d32f2f;
         /* Overlay Colors */
         --overlay-bg: rgba(0, 0, 0, 0.5);
         --loading-overlay-bg: black;
         --loading-credits-color: rgb(245, 245, 245);
         /* Scrollbar Colors */
         --scrollbar-thumb: rgb(50, 50, 50);
         --scrollbar-track: transparent;
         /* Shadow Colors */
         --shadow-dark: rgba(0, 0, 0, 0.5);
         --shadow-medium: rgba(0, 0, 0, 0.6);
         --shadow-light: rgba(0, 0, 0, 0.4);
         /* Spacing Values */
         --spacing-xs: 4px;
         --spacing-sm: 8px;
         --spacing-md: 12px;
         --spacing-lg: 16px;
         --spacing-xl: 20px;
         --spacing-xxl: 25px;
         --spacing-xxxl: 30px;
         /* Border Radius */
         --radius-sm: 5px;
         --radius-md: 8px;
         --radius-lg: 10px;
         --radius-xl: 12px;
         --radius-full: 50%;
         /* Font Sizes */
         --font-sm: 0.9rem;
         --font-base: 1rem;
         --font-md: 1.1rem;
         --font-lg: 1.2rem;
         --font-xl: 1.6rem;
         --font-xxl: 1.7rem;
         --font-xxxl: 1.8rem;
         --font-icon-sm: 1.2rem;
         --font-icon-md: 1.8rem;
         --font-icon-lg: 2.1rem;
         --font-icon-xl: 64px;
         /* Transitions */
         --transition-fast: 0.2s ease;
         --transition-base: 0.3s ease;
         --transition-slow: 0.4s all;
         --transition-slower: 0.5s;
         /* Z-index */
         --z-overlay: 1;
         --z-header: 10;
         --z-sidebar: 20;
         --z-signin: 99999;
         --z-loading: 500000;
         /* Dimensions */
         --sidebar-width: 260px;
         --avatar-sm: 40px;
         --avatar-md: 70px;
         --avatar-lg: 80px;
         --scrollbar-width: 6px;
         }
         /* Light theme overrides */
         body.light-theme {
         --bg-primary: #ffffff;
         --bg-secondary: rgb(253, 253, 253);
         --bg-tertiary: rgb(240, 240, 240);
         --bg-gradient-dark: linear-gradient(145deg, #ffffff, #f0f0f0);
         --bg-input: #ffffff;
         --bg-profile: rgb(253, 253, 253);
         --text-primary: #333;
         --text-secondary: rgb(50, 50, 50);
         --text-tertiary: rgb(80, 80, 80);
         --text-muted: #333;
         --text-light-gray: rgb(50, 50, 50);
         --text-dark-gray: rgb(90, 90, 90);
         --accent-button-text: rgb(30, 30, 30);
         --error-color: #d32f2f;
         --error-bg: #ff6666;
         --error-hover: #ff4d4d;
         --loading-overlay-bg: rgb(253, 253, 253);
         --loading-credits-color: rgb(50, 50, 50);
         --scrollbar-thumb: rgb(170, 170, 170);
         --shadow-dark: rgba(0, 0, 0, 0.1);
         --shadow-medium: rgba(0, 0, 0, 0.1);
         --shadow-light: rgba(0, 0, 0, 0.1);
         }
         * {
         margin: 0;
         padding: 0;
         box-sizing: border-box;
         font-family: 'Roboto', sans-serif;
         max-height: 999999px;
         transition: var(--transition-base) all;
         }
         .noselect {
         -webkit-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
         -webkit-touch-callout: none;
         -webkit-user-drag: none;
         -webkit-tap-highlight-color: transparent;
         }
         body {
         background: var(--bg-primary);
         color: var(--text-primary);
         min-height: 100vh;
         overflow-y: auto;
         }
         ::-webkit-scrollbar {
         width: var(--scrollbar-width);
         }
         ::-webkit-scrollbar-track {
         background: var(--scrollbar-track);
         }
         ::-webkit-scrollbar-thumb {
         background: var(--scrollbar-thumb);
         border-radius: var(--radius-lg);
         }
         .container {
         max-width: 800px;
         margin: 0 auto;
         padding: var(--spacing-xl);
         }
         .header {
         padding: var(--spacing-xl) 0;
         margin-bottom: var(--spacing-lg);
         display: none;
         }
         .header h1 {
         font-size: var(--font-xxl);
         font-weight: 500;
         color: var(--text-primary);
         }
         .notifications-list {
         display: flex;
         flex-direction: column;
         gap: var(--spacing-md);
         }
         .notification-card {
         background: var(--bg-secondary);
         border-radius: var(--radius-lg);
         padding: var(--spacing-lg);
         cursor: pointer;
         box-shadow: 0 2px 8px var(--shadow-light);
         transition: var(--transition-fast);
         }
         .notification-card:hover {
         background: var(--bg-tertiary);
         transform: translateY(-2px);
         box-shadow: 0 4px 12px var(--shadow-medium);
         }
         .notification-card:active {
         transform: translateY(0);
         }
         .notification-card.unread {
         border-left: 4px solid var(--accent-primary);
         background: var(--bg-tertiary);
         position: relative;
         }
         .notification-card.unread::before {
         content: '';
         position: absolute;
         top: var(--spacing-lg);
         right: var(--spacing-lg);
         width: 8px;
         height: 8px;
         background: var(--accent-primary);
         border-radius: var(--radius-full);
         box-shadow: 0 0 8px var(--accent-primary);
         }
         /* Adjust hover for unread to be more subtle */
         .notification-card.unread:hover {
         background: var(--bg-tertiary);
         opacity: 0.95;
         }
         .notification-header {
         display: flex;
         justify-content: space-between;
         align-items: flex-start;
         margin-bottom: var(--spacing-sm);
         gap: var(--spacing-md);
         }
         .notification-title {
         font-size: var(--font-md);
         font-weight: 500;
         color: var(--text-primary);
         flex: 1;
         }
         .notification-time {
         font-size: var(--font-sm);
         color: var(--text-tertiary);
         white-space: nowrap;
         flex-shrink: 0;
         }
         .notification-body {
         font-size: var(--font-base);
         color: var(--text-secondary);
         line-height: 1.5;
         margin-bottom: var(--spacing-sm);
         }
         .notification-sender {
         font-size: var(--font-sm);
         color: var(--text-tertiary);
         font-style: italic;
         }
         .loading-spinner {
         display: flex;
         justify-content: center;
         align-items: center;
         padding: var(--spacing-xl);
         opacity: 0;
         transition: opacity var(--transition-base);
         }
         .loading-spinner.visible {
         opacity: 1;
         }
         .spinner {
         width: 40px;
         height: 40px;
         border: 3px solid var(--bg-tertiary);
         border-top-color: var(--accent-primary);
         border-radius: var(--radius-full);
         animation: spin 0.8s linear infinite;
         }
         @keyframes spin {
         to { transform: rotate(360deg); }
         }
         .no-notifications {
         text-align: center;
         padding: var(--spacing-xxxl);
         color: var(--text-tertiary);
         font-size: var(--font-md);
         }
         @media (max-width: 600px) {
         .container {
         padding: var(--spacing-md);
         }
         .notification-card {
         padding: var(--spacing-md);
         }
         .notification-header {
         flex-direction: column;
         gap: var(--spacing-xs);
         }
         .notification-time {
         align-self: flex-start;
         }
         .header h1 {
         font-size: var(--font-xl);
         }
         }
         /* Search Container */
         .search-container {
         display: flex;
         align-items: center;
         gap: var(--spacing-sm);
         margin-bottom: var(--spacing-xl);
         padding: var(--spacing-sm) 0;
         }
         .search-toggle {
         width: 44px;
         height: 44px;
         border-radius: var(--radius-lg);
         background: var(--bg-secondary);
         border: none;
         cursor: pointer;
         display: flex;
         align-items: center;
         justify-content: center;
         transition: var(--transition-fast);
         flex-shrink: 0;
         box-shadow: 0 2px 8px var(--shadow-light);
         }
         .search-toggle:hover {
         background: var(--bg-tertiary);
         transform: scale(1.05);
         }
         .search-toggle:active {
         transform: scale(0.95);
         }
         .search-toggle.active {
         background: var(--accent-primary);
         }
         .search-toggle.active .search-icon {
         stroke: var(--accent-button-text);
         }
         .search-icon {
         stroke: var(--text-primary);
         transition: var(--transition-fast);
         }
         .search-input-wrapper {
         position: relative;
         flex: 1;
         max-width: 0;
         opacity: 0;
         overflow: hidden;
         transition: max-width var(--transition-base), opacity var(--transition-base);
         }
         .search-input-wrapper.expanded {
         max-width: 600px;
         opacity: 1;
         }
         .search-input {
         width: 100%;
         padding: var(--spacing-md) var(--spacing-xl);
         padding-right: 40px;
         border-radius: var(--radius-lg);
         background: var(--bg-input);
         border: 2px solid transparent;
         color: var(--text-primary);
         font-size: var(--font-base);
         outline: none;
         transition: var(--transition-fast);
         box-shadow: 0 2px 8px var(--shadow-light);
         }
         .search-input:focus {
         border-color: var(--accent-primary);
         box-shadow: 0 4px 12px var(--shadow-medium);
         }
         .search-input::placeholder {
         color: var(--text-tertiary);
         }
         .search-clear {
         position: absolute;
         right: var(--spacing-sm);
         top: 50%;
         transform: translateY(-50%);
         width: 32px;
         height: 32px;
         border-radius: var(--radius-md);
         background: transparent;
         border: none;
         cursor: pointer;
         display: none;
         align-items: center;
         justify-content: center;
         transition: var(--transition-fast);
         padding: 0;
         }
         .search-clear:hover {
         background: var(--bg-tertiary);
         }
         .search-clear.visible {
         display: flex;
         }
         .search-clear svg {
         stroke: var(--text-tertiary);
         }
         .search-clear:hover svg {
         stroke: var(--text-primary);
         }
         /* Search Status */
         .search-status {
         padding: var(--spacing-md) 0;
         text-align: center;
         color: var(--text-tertiary);
         font-size: var(--font-sm);
         display: none;
         }
         .search-status.visible {
         display: block;
         }
         /* Highlight matched text */
         .highlight {
         background: var(--accent-primary);
         color: var(--accent-button-text);
         padding: 2px 4px;
         border-radius: 3px;
         font-weight: 500;
         }
         /* Hide notification cards with display none for better performance */
         .notification-card.hidden {
         display: none;
         }
         /* Responsive */
         @media (max-width: 600px) {
         .search-container {
         margin-bottom: var(--spacing-lg);
         }
         .search-toggle {
         width: 40px;
         height: 40px;
         }
         .search-input {
         padding: var(--spacing-sm) var(--spacing-md);
         padding-right: 36px;
         font-size: var(--font-sm);
         }
         }
      </style>
   </head>
   <body>
      <div class="container">
         <!-- Search Bar -->
         <div class="search-container">
            <button class="search-toggle noselect" id="searchToggle" aria-label="Toggle search">
               <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
               </svg>
            </button>
            <div class="search-input-wrapper" id="searchInputWrapper">
               <input 
                  type="text" 
                  class="search-input" 
                  id="searchInput" 
                  placeholder="Search notifications..."
                  autocomplete="off"
                  />
               <button class="search-clear noselect" id="searchClear" aria-label="Clear search">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <line x1="18" y1="6" x2="6" y2="18"></line>
                     <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
               </button>
            </div>
         </div>
         <div class="search-status" id="searchStatus"></div>
         <div class="header">
            <h1>Notifications</h1>
         </div>
         <div class="notifications-list" id="notificationsList"></div>
         <div class="loading-spinner" id="loadingSpinner">
            <div class="spinner"></div>
         </div>
      </div>
      <script>
         // Global notifications array
         let notifications = [];
         
         // Search state
         let isSearchActive = false;
         let searchQuery = '';
         let allLoadedNotifications = []; // Store all loaded notifications during search
         let isBackgroundLoading = false;
         
         
         const notificationsList = document.getElementById('notificationsList');
         const loadingSpinner = document.getElementById('loadingSpinner');
         let isLoading = false;
         let hasMore = true;
         
         // Time ago formatter
         function timeAgo(timestamp) {
           const now = new Date();
           const time = new Date(timestamp);
           const diff = Math.floor((now - time) / 1000);
         
           if (diff < 60) return 'just now';
           if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
           if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
           if (diff < 2592000) return `${Math.floor(diff / 86400)}d ago`;
           if (diff < 31536000) return `${Math.floor(diff / 2592000)}mo ago`;
           return `${Math.floor(diff / 31536000)}y ago`;
         }
         
         // Create notification card element
         function createNotificationCard(notification, highlightText = '') {
         const card = document.createElement('div');
         card.className = 'notification-card';
         card.dataset.id = notification.id;
         
         // Add 'unread' class if is_read is 0
         if (notification.is_read === 0) {
         card.className += ' unread';
         }
         
         // Function to highlight matching text
         const highlight = (text, query) => {
         if (!query) return text;
         const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
         return text.replace(regex, '<span class="highlight">$1</span>');
         };
         
         const title = highlightText ? highlight(notification.message_title, highlightText) : notification.message_title;
         const body = highlightText ? highlight(notification.message_body, highlightText) : notification.message_body;
         const sender = highlightText ? highlight(notification.sent_by, highlightText) : notification.sent_by;
         
         card.innerHTML = `
         <div class="notification-header">
           <div class="notification-title">${title}</div>
           <div class="notification-time">${timeAgo(notification.created_at)}</div>
         </div>
         <div class="notification-body">${body}</div>
         <div class="notification-sender">From: ${sender}</div>
         `;
         
         card.addEventListener('click', () => {
         if (typeof loadNotification === 'function') {
           loadNotification(notification.id);
         }
         });
         
         return card;
         }
         
         // Render notifications (newest first)
         function renderNotifications(notifs, append = false) {
           if (!append) {
             notificationsList.innerHTML = '';
           }
         
           notifs.forEach(notification => {
             const card = createNotificationCard(notification);
             notificationsList.appendChild(card);
           });
         }
         
         // Check if page is scrollable
         function isPageScrollable() {
           return document.documentElement.scrollHeight > window.innerHeight;
         }
         
         // Load more notifications
         async function loadMore() {
           if (isLoading || !hasMore) return;
         
           isLoading = true;
           loadingSpinner.classList.add('visible');
         
           const lastNotification = notificationsList.lastElementChild;
           if (!lastNotification) {
             isLoading = false;
             loadingSpinner.classList.remove('visible');
             return;
           }
         
           const lastId = lastNotification.dataset.id;
         
           try {
             // Call the fetchNotifications function
             const newNotifications = await fetchNotifications(lastId);
         
             if (newNotifications && newNotifications.length > 0) {
               notifications.push(...newNotifications);
               renderNotifications(newNotifications, true);
             } else {
               hasMore = false;
             }
           } catch (error) {
             console.error('Error loading notifications:', error);
           } finally {
             isLoading = false;
             loadingSpinner.classList.remove('visible');
           }
         }
         
         // Initialize and load until scrollable
         async function initializePage(userData) {
            notifications = userData['notifications']['notifications'];
           // Sort by newest first
           notifications.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
           renderNotifications(notifications);
         
           // Load more until page is scrollable
           while (!isPageScrollable() && hasMore) {
             await loadMore();
           }
         }
         
         // Intersection Observer for lazy loading
         const observer = new IntersectionObserver((entries) => {
           entries.forEach(entry => {
             if (entry.isIntersecting && !isLoading && hasMore) {
               loadMore();
             }
           });
         }, {
           rootMargin: '100px'
         });
         
         // Observe the loading spinner
         observer.observe(loadingSpinner);
         
         // Search UI Event Listeners
         const searchToggle = document.getElementById('searchToggle');
         const searchInputWrapper = document.getElementById('searchInputWrapper');
         const searchInput = document.getElementById('searchInput');
         const searchClear = document.getElementById('searchClear');
         
         searchToggle.addEventListener('click', () => {
         const isExpanded = searchInputWrapper.classList.contains('expanded');
         
         if (isExpanded) {
         // Collapse search
         searchInputWrapper.classList.remove('expanded');
         searchToggle.classList.remove('active');
         searchInput.value = '';
         searchQuery = '';
         isSearchActive = false;
         isBackgroundLoading = false;
         
         // Remove highlights by re-rendering all visible notifications
         const visibleNotifications = notifications.concat(allLoadedNotifications.filter(n => 
           !notifications.find(existing => existing.id === n.id)
         ));
         
         notificationsList.innerHTML = '';
         renderNotifications(visibleNotifications, false);
         allLoadedNotifications = [];
         
         searchClear.classList.remove('visible');
         document.getElementById('searchStatus').classList.remove('visible');
         } else {
         // Expand search
         searchInputWrapper.classList.add('expanded');
         searchToggle.classList.add('active');
         setTimeout(() => searchInput.focus(), 300);
         }
         });
         
         searchInput.addEventListener('input', (e) => {
         searchQuery = e.target.value.trim();
         
         // Show/hide clear button
         if (searchQuery) {
         searchClear.classList.add('visible');
         } else {
         searchClear.classList.remove('visible');
         }
         
         // Activate search mode on first keystroke
         if (searchQuery && !isSearchActive) {
         isSearchActive = true;
         allLoadedNotifications = [...notifications];
         // Start background loading
         backgroundLoadNotifications();
         }
         
         // Filter notifications as user types
         filterNotifications(searchQuery);
         
         // Deactivate search if query is cleared
         if (!searchQuery && isSearchActive) {
         isSearchActive = false;
         isBackgroundLoading = false;
         allLoadedNotifications = [];
         }
         });
         
         searchClear.addEventListener('click', () => {
         searchInput.value = '';
         searchQuery = '';
         isSearchActive = false;
         isBackgroundLoading = false;
         allLoadedNotifications = [];
         
         // Remove highlights by re-rendering all visible notifications
         const visibleNotifications = notifications.concat(allLoadedNotifications.filter(n => 
         !notifications.find(existing => existing.id === n.id)
         ));
         
         notificationsList.innerHTML = '';
         renderNotifications(visibleNotifications, false);
         
         searchClear.classList.remove('visible');
         document.getElementById('searchStatus').classList.remove('visible');
         
         // Collapse the search input
         searchInputWrapper.classList.remove('expanded');
         searchToggle.classList.remove('active');
         });
         
         // Close search on Escape key
         searchInput.addEventListener('keydown', (e) => {
         if (e.key === 'Escape') {
         searchToggle.click();
         }
         });
         
         // Search functionality
         function filterNotifications(query) {
         if (!query) {
         // Show all loaded notifications and remove highlights
         const cards = document.querySelectorAll('.notification-card');
         cards.forEach(card => {
            const notification = allLoadedNotifications.find(n => n.id === card.dataset.id) || notifications.find(n => n.id === card.dataset.id);
            if (notification) {
                const newCard = createNotificationCard(notification, ''); // Re-render without highlight
                card.innerHTML = newCard.innerHTML;
            }
            card.classList.remove('hidden');
         });
         updateSearchStatus('');
         return;
         }
         
         const searchLower = query.toLowerCase();
         const allNotifs = isSearchActive ? allLoadedNotifications : notifications;
         let visibleCount = 0;
         
         allNotifs.forEach(notification => {
         const card = document.querySelector(`.notification-card[data-id="${notification.id}"]`);
         if (!card) return;
         
         // Enhancement: Added sender match
         const titleMatch = notification.message_title.toLowerCase().includes(searchLower);
         const bodyMatch = notification.message_body.toLowerCase().includes(searchLower);
         const senderMatch = notification.sent_by.toLowerCase().includes(searchLower);
         
         if (titleMatch || bodyMatch || senderMatch) {
            // A match is found: highlight the content and show the card
            const newCard = createNotificationCard(notification, query);
            card.innerHTML = newCard.innerHTML;
            card.classList.remove('hidden');
            visibleCount++;
         } else {
            // No match: remove highlights and hide the card
            const newCard = createNotificationCard(notification, ''); // Re-render without highlights
            card.innerHTML = newCard.innerHTML;
            card.classList.add('hidden');
         }
         });
         
         updateSearchStatus(query, visibleCount);
         }
         
         function updateSearchStatus(query, count = 0) {
         const status = document.getElementById('searchStatus');
         if (!query) {
         status.classList.remove('visible');
         return;
         }
         
         if (isBackgroundLoading) {
         status.textContent = `Found ${count} results (loading more...)`;
         } else if (count === 0) {
         status.textContent = 'No notifications found';
         } else if (count === 1) {
         status.textContent = '1 notification found';
         } else {
         status.textContent = `${count} notifications found`;
         }
         status.classList.add('visible');
         }
         
         // Background loading during search
         async function backgroundLoadNotifications() {
         if (isBackgroundLoading || !hasMore) return;
         
         isBackgroundLoading = true;
         
         try {
         const lastNotif = allLoadedNotifications[allLoadedNotifications.length - 1];
         const lastId = lastNotif ? lastNotif.id : (notifications[notifications.length - 1]?.id);
         
         if (!lastId) {
           isBackgroundLoading = false;
           return;
         }
         
         const newNotifications = await fetchNotifications(lastId);
         
         if (newNotifications && newNotifications.length > 0) {
           allLoadedNotifications.push(...newNotifications);
           
           // Render new notifications (they will be filtered immediately)
           newNotifications.forEach(notification => {
             const card = createNotificationCard(notification, searchQuery);
             notificationsList.appendChild(card);
           });
         
           // Apply current search filter to new cards
           if (searchQuery) {
             filterNotifications(searchQuery);
           }
         
           // Continue loading if still searching
           if (isSearchActive && hasMore) {
             setTimeout(() => {
               isBackgroundLoading = false;
               backgroundLoadNotifications();
             }, 300); // Small delay between requests
           } else {
             isBackgroundLoading = false;
           }
         } else {
           hasMore = false;
           isBackgroundLoading = false;
           if (searchQuery) {
             updateSearchStatus(searchQuery, document.querySelectorAll('.notification-card:not(.hidden)').length);
           }
         }
         } catch (error) {
         console.error('Error loading notifications:', error);
         isBackgroundLoading = false;
         }
         }
         
         // Function to lazy load more notifications for the page
         async function fetchNotifications(lastNotifId) {
           const data = await parent.getNotifications(lastNotifId, 5);
           return data.notifications || [];
         }
         
         function loadNotification(notificationId) {
             // First, mark it as read in the notifications array in the main app page
             const notification = notifications.find(n => n.id === notificationId);
             if (notification) notification.is_read = 1;
             
             window.parent.loadManualPage({link: './pages/notifications/show.html?notification_id=' + notificationId, title: 'Notifications', page_key: 'show-notification'});
         }
         
         // Update timestamps periodically
         setInterval(() => {
           const timeElements = document.querySelectorAll('.notification-time');
           const cards = document.querySelectorAll('.notification-card');
           cards.forEach((card, index) => {
             const notifId = card.dataset.id;
             const notif = notifications.find(n => n.id === notifId);
             if (notif && timeElements[index]) {
               timeElements[index].textContent = timeAgo(notif.created_at);
             }
           });
         }, 60000); // Update every minute

         // function that the parent app page will call just in case new notifications arrive while the app is open
         function prependNewNotifications(newNotifs) {
           if (!newNotifs || newNotifs.length === 0) return;
           
           // The list comes in [newest, newer, new]
           // We reverse it to prepend in the correct order [new, newer, newest]
           newNotifs.slice().reverse().forEach(notification => {
             
             // 1. Add to the global 'notifications' array in this iframe
             notifications.unshift(notification);
             
             // 2. If search is active, add to 'allLoadedNotifications' as well
             if (isSearchActive) {
                allLoadedNotifications.unshift(notification);
             }

             // 3. Create the new card element
             const card = createNotificationCard(notification, searchQuery);
             
             // 4. Add the card to the very top of the list in the DOM
             notificationsList.prepend(card);
           });

           // 5. If search is active, re-apply the filter to highlight/hide new cards
           if (isSearchActive && searchQuery) {
              filterNotifications(searchQuery);
           }
         }
      </script>
   </body>
</html>